<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Game</title>
    <style>
        canvas {
            border: 1px solid black;
            background-color: white;
            display: none; /* Initially hide the canvas */
        }
        #playButton {
            font-size: 20px;
        }
        #tokenInputContainer {
            margin-bottom: 10px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/3.0.0/js.cookie.min.js"></script>
</head>
<body>
    <div id="tokenInputContainer">
        <input type="text" id="tokenInput" placeholder="Enter Token Number" />
        <button id="submitTokenButton">Submit Token</button>
        <button id="createTokenButton">Create Token</button>
        <button id="clearTokenButton">Clear Token</button>
    </div>
    <button id="playButton">Play</button>
    <h2 id="scoreBoard" style="display:none;">Best Score: <span id="bestScore">0</span></h2>
    <h2 id="currentScoreBoard" style="display:none;">Current Score: <span id="currentScore">0</span></h2>
    <canvas id="gameCanvas" width="800" height="600" tabindex="0"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const playButton = document.getElementById('playButton');
        const tokenInput = document.getElementById('tokenInput');
        const submitTokenButton = document.getElementById('submitTokenButton');
        const createTokenButton = document.getElementById('createTokenButton');
        const clearTokenButton = document.getElementById('clearTokenButton');
        const scoreBoard = document.getElementById('scoreBoard');
        const bestScoreDisplay = document.getElementById('bestScore');
        const currentScoreDisplay = document.getElementById('currentScore'); // Current score display
        const currentScoreBoard = document.getElementById('currentScoreBoard'); // Current score element

        let bestScore = 0;
        let currentScore = 0;
        const obstacles = [];
        const visitedAreas = new Set();

        const user = {
            x: 50,
            y: 50,
            size: 10
        };

        function generateToken() {
            return Math.random().toString(36).substring(2, 10);
        }

        function initializeObstacles() {
            for (let i = 0; i < 5; i++) {
                obstacles.push({
                    x: Math.random() * (canvas.width - 50),
                    y: Math.random() * (canvas.height - 50),
                    width: 50,
                    height: 50,
                });
            }
        }

        function isOnObstacle(x, y) {
            return obstacles.some(obstacle => 
                x < obstacle.x + obstacle.width &&
                x + user.size > obstacle.x &&
                y < obstacle.y + obstacle.height &&
                y + user.size > obstacle.y
            );
        }

        function drawObstacles() {
            ctx.fillStyle = 'red';
            obstacles.forEach(obstacle => { 
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });
        }

        function endGame() {
            alert('Game Over!');
            if (tokenInput.value) {
                if (currentScore > bestScore) {
                    bestScore = currentScore;
                    bestScoreDisplay.textContent = bestScore;
                    fetch('/entries', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: tokenInput.value, content: bestScore })
                    }).catch(err => console.error('Error sending score:', err));
                }
            }
            scoreBoard.style.display = 'block';
            currentScoreBoard.style.display = 'none'; // Hide current score on game over

            // Reset for a new game
            currentScore = 0; 
            clearCanvas(); // Clear the canvas for the next game
            drawObstacles(); // Draw obstacles again for the next game

            // Automatically restart the game
            setTimeout(() => {
                startNewGame();
            }, 2000); // Delay before restart
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function startNewGame() {
            visitedAreas.clear(); // Clear visited areas for the new game
            initializeObstacles();
            currentScore = 0; // Reset current score
            currentScoreDisplay.textContent = currentScore; // Update current score display
            currentScoreBoard.style.display = 'block'; // Show current score display

            // Ensure user starts at a valid location
            do {
                user.x = Math.floor(Math.random() * (canvas.width - user.size));
                user.y = Math.floor(Math.random() * (canvas.height - user.size));
            } while (isOnObstacle(user.x, user.y));

            clearCanvas();
            drawObstacles();
            drawUser();
            document.addEventListener('keydown', moveUser);
            canvas.focus();
        }

        playButton.addEventListener('click', () => {
            canvas.style.display = 'block';
            playButton.style.display = 'none';
            scoreBoard.style.display = 'none';
            startNewGame(); // Start the first game
        });

        async function fetchBestScore(token) {
            try {
                const response = await fetch(`/entries/${token}`);
                if (response.ok) {
                    const data = await response.json();
                    return data.content;
                }
            } catch (err) {
                console.error('Error fetching score:', err);
            }
            return 0;
        }

        submitTokenButton.addEventListener('click', async () => {
            const tokenValue = tokenInput.value.trim();
            if (tokenValue) {
                Cookies.set('game_token', tokenValue, { expires: 7 });
                bestScore = await fetchBestScore(tokenValue);
                bestScoreDisplay.textContent = bestScore;
                scoreBoard.style.display = 'block';
                alert(`Token set: ${tokenValue}`);
            } else {
                alert('Please enter a valid token.');
            }
        });

        createTokenButton.addEventListener('click', () => {
            const newToken = generateToken();
            tokenInput.value = newToken;
            Cookies.set('game_token', newToken, { expires: 7 });
            alert(`New token created: ${newToken}`);
            bestScore = 0; // Reset best score for new token
            bestScoreDisplay.textContent = bestScore; // Update display to show zero
        });

        clearTokenButton.addEventListener('click', () => {
            Cookies.remove('game_token');
            tokenInput.value = '';
            alert('Token cleared!');
        });

        window.onload = () => {
            const token = Cookies.get('game_token');
            if (token) {
                tokenInput.value = token;
                alert(`Welcome back! Your token is: ${token}`);
            }
        };

        function moveUser(event) {
            const step = 5;
            let previousX = user.x;
            let previousY = user.y;

            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    user.y = Math.max(user.y - step, 0);
                    break;
                case 'ArrowDown':
                case 's':
                    user.y = Math.min(user.y + step, canvas.height - user.size);
                    break;
                case 'ArrowLeft':
                case 'a':
                    user.x = Math.max(user.x - step, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                    user.x = Math.min(user.x + step, canvas.width - user.size);
                    break;
            }

            if (checkCollision(user)) {
                endGame();
            } else {
                currentScore++; // Increment score when user moves to a new area
                currentScoreDisplay.textContent = currentScore; // Update the current score display
                visitedAreas.add(`${Math.floor(user.x)}:${Math.floor(user.y)}`);
            }
            draw(); // Continuously redraw the canvas
        }

        function checkCollision(user) {
            for (const obstacle of obstacles) {
                if (user.x < obstacle.x + obstacle.width &&
                    user.x + user.size > obstacle.x &&
                    user.y < obstacle.y + obstacle.height &&
                    user.y + user.size > obstacle.y) {
                    return true; 
                }
            }
            return visitedAreas.has(`${Math.floor(user.x)}:${Math.floor(user.y)}`);
        }

        function draw() {
            clearCanvas(); // Clear the canvas
            drawObstacles(); 
            drawVisitedAreas();
            drawUser();
        }

        function drawVisitedAreas() {
            ctx.fillStyle = 'blue';
            visitedAreas.forEach(area => {
                const [x, y] = area.split(':').map(Number);
                ctx.fillRect(x, y, user.size, user.size); 
            });
        }

        function drawUser() {
            ctx.fillStyle = 'blue'; 
            ctx.beginPath();
            ctx.arc(user.x, user.y, user.size, 0, Math.PI * 2);
            ctx.fill();
        }
    </script>
</body>
</html>